/**
 * Gemini service for generating visual content.
 * Uses Gemini 3 Pro for image generation (infographics, carousels, images).
 * Video briefs are generated by OpenAI GPT-5.
 */

import { AI_CONFIG, getGoogleAIKey } from './aiConfig';
import { MediaType, MediaContent } from '@/types/pipeline';
import { generateMediaContent as mockGenerateMedia, regenerateWithFeedback as mockRegenerate } from './mockMediaDesign';
import { generateVideoBrief, generateSocialContent } from './openaiService';

interface GeminiResponse {
    candidates?: Array<{
        content?: {
            parts?: Array<{
                text?: string;
                inlineData?: {
                    mimeType: string;
                    data: string;
                };
            }>;
        };
    }>;
    error?: {
        message: string;
    };
}

/**
 * Generate image prompt based on media type and angle
 */
function generateImagePrompt(angle: string, mediaType: MediaType): string {
    const baseStyle = `Professional business visual with modern, premium aesthetic. 
Dark gradient background (#0a0a0f to #1a1a2e). 
Accent colors: cyan (#00eaff) and purple gradients. 
Clean, minimalist design with subtle geometric elements.
No text overlays - let the visual speak for itself.`;

    const typePrompts: Record<MediaType, string> = {
        infographic: `Create a professional data visualization infographic about: "${angle}"
${baseStyle}
Include abstract data representations, charts iconography, and flowing connection lines.
Visual hierarchy with key stats represented as glowing nodes.
Suitable for LinkedIn and Instagram.`,

        carousel: `Create a single slide for a professional carousel about: "${angle}"
${baseStyle}
Feature one key concept with visual metaphor.
Bold, impactful imagery with depth and dimension.
Modern 3D elements or abstract shapes.`,

        image: `Create a striking social media image representing: "${angle}"
${baseStyle}
Abstract visualization of the concept.
Premium, executive feel with subtle gradients.
Inspiring and thought-provoking visual metaphor.
Square format for Instagram/LinkedIn.`,

        video: `Create a thumbnail/cover image for a video about: "${angle}"
${baseStyle}
Dynamic, motion-implied imagery.
High contrast with focal point.
Suggests depth and energy.`
    };

    return typePrompts[mediaType];
}

/**
 * Generate caption and social content using Gemini
 */
function generateTextPrompt(angle: string, mediaType: MediaType): string {
    return `You are a social media strategist for thought leaders. 
Create engaging social media content for this post about: "${angle}"

Media type: ${mediaType}

Generate content with these fields (respond in JSON format only):
{
    "caption": "A compelling social media caption (200-300 words) with:
        - Attention-grabbing hook in first line
        - 2-3 key insights or points
        - Personal perspective or experience reference
        - Call to action for engagement
        - Use emojis strategically",
    "description": "Brief SEO description (under 160 chars)",
    "hashtags": ["array", "of", "5-7", "relevant", "hashtags"]
}

Only respond with valid JSON, no additional text.`;
}

/**
 * Parse text content response from Gemini
 */
function parseTextContent(content: string): { caption: string; description: string; hashtags: string[] } {
    try {
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
            throw new Error('No JSON found');
        }

        const parsed = JSON.parse(jsonMatch[0]);
        return {
            caption: parsed.caption || 'Share your perspective on this topic.',
            description: parsed.description || 'Leadership insights for professionals.',
            hashtags: Array.isArray(parsed.hashtags) ? parsed.hashtags : ['#Leadership', '#ThoughtLeadership'],
        };
    } catch {
        return {
            caption: `ðŸ’¡ Share your perspective on this important topic.\n\nThe best leaders know that real impact comes from sharing insights that matter.\n\nðŸ’¬ What's your take? Share your thoughts below!`,
            description: 'Leadership insights for professionals.',
            hashtags: ['#Leadership', '#ThoughtLeadership', '#BusinessStrategy', '#ExecutiveInsights'],
        };
    }
}

/**
 * Delay helper for retry logic
 */
function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Parse retryDelay from Gemini error response (e.g., "30s" or "30.720934694s")
 */
function parseRetryDelay(errorData: unknown): number {
    try {
        const data = errorData as { error?: { details?: Array<{ '@type'?: string; retryDelay?: string }> } };
        const details = data?.error?.details || [];

        for (const detail of details) {
            if (detail['@type']?.includes('RetryInfo') && detail.retryDelay) {
                // Parse "30s" or "30.720934694s" format
                const match = detail.retryDelay.match(/^(\d+(?:\.\d+)?)s$/);
                if (match) {
                    return Math.ceil(parseFloat(match[1]) * 1000); // Convert to ms
                }
            }
        }
    } catch {
        // Fall back to default
    }
    return 60000; // Default 60 seconds
}

/**
 * Delay with countdown logging
 */
async function delayWithCountdown(ms: number, label: string): Promise<void> {
    const totalSeconds = Math.ceil(ms / 1000);
    console.log(`[${label}] Rate limited. Waiting ${totalSeconds} seconds...`);

    for (let remaining = totalSeconds; remaining > 0; remaining--) {
        if (remaining % 10 === 0 || remaining <= 5) {
            console.log(`[${label}] Retry in ${remaining}s...`);
        }
        await delay(1000);
    }
}

/**
 * Call Gemini API for image generation with retry logic
 */
async function callGeminiImageAPI(prompt: string, apiKey: string, retries = 3): Promise<string | null> {
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${AI_CONFIG.gemini.model}:generateContent`;

    for (let attempt = 0; attempt <= retries; attempt++) {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-goog-api-key': apiKey,
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    responseModalities: ["Text", "Image"]
                }
            }),
        });

        if (response.ok) {
            const data: GeminiResponse = await response.json();
            const parts = data.candidates?.[0]?.content?.parts || [];
            for (const part of parts) {
                if (part.inlineData?.data) {
                    return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                }
            }
            return null;
        }

        // Handle rate limiting with dynamic delay from API response
        if (response.status === 429 && attempt < retries) {
            const errorData = await response.json().catch(() => ({}));
            const waitTime = parseRetryDelay(errorData);
            await delayWithCountdown(waitTime, 'Gemini Image');
            continue;
        }

        const error = await response.json().catch(() => ({}));
        console.error('[Gemini] API error:', response.status, error);
        return null;
    }

    return null;
}

/**
 * Call Gemini API for text generation with retry logic
 */
async function callGeminiTextAPI(prompt: string, apiKey: string, retries = 3): Promise<string | null> {
    // Use standard Gemini model for text
    const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent`;

    for (let attempt = 0; attempt <= retries; attempt++) {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-goog-api-key': apiKey,
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
            }),
        });

        if (response.ok) {
            const data: GeminiResponse = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || null;
        }

        // Handle rate limiting with dynamic delay from API response
        if (response.status === 429 && attempt < retries) {
            const errorData = await response.json().catch(() => ({}));
            const waitTime = parseRetryDelay(errorData);
            await delayWithCountdown(waitTime, 'Gemini Text');
            continue;
        }

        return null;
    }

    return null;
}

/**
 * Generate media content using Gemini
 */
export async function generateMediaContent(
    selectedAngle: string,
    mediaType: MediaType
): Promise<MediaContent> {
    const apiKey = getGoogleAIKey();

    // Fall back to mock if no API key
    if (!apiKey) {
        console.log('[Gemini] No API key configured, using mock service');
        return mockGenerateMedia(selectedAngle, mediaType);
    }

    try {
        // Generate image with Gemini and text content with OpenAI in parallel
        const imagePrompt = generateImagePrompt(selectedAngle, mediaType);

        const [imageUrl, socialContent] = await Promise.all([
            callGeminiImageAPI(imagePrompt, apiKey),
            generateSocialContent(selectedAngle, mediaType),
        ]);

        // Use OpenAI-generated text content
        const { caption, description, hashtags } = socialContent;

        // If we got an image, use it; otherwise fall back to mock
        if (imageUrl) {
            const content: MediaContent = {
                type: mediaType,
                imageUrl,
                caption,
                description,
                hashtags,
            };

            // For carousel, generate additional images
            if (mediaType === 'carousel') {
                const additionalImages = await Promise.all([
                    callGeminiImageAPI(imagePrompt + '\nCreate a variation - second slide.', apiKey),
                    callGeminiImageAPI(imagePrompt + '\nCreate a variation - third slide.', apiKey),
                ]);
                content.previewUrls = [imageUrl, ...additionalImages.filter(Boolean) as string[]];
            }

            // For video, generate brief using GPT-5
            if (mediaType === 'video') {
                content.videoBrief = await generateVideoBrief(selectedAngle);
            }

            return content;
        }

        // Fall back to mock if image generation failed
        console.log('[Gemini] Image generation failed, using mock with AI-generated text');
        const mockContent = await mockGenerateMedia(selectedAngle, mediaType);
        return {
            ...mockContent,
            caption,
            description,
            hashtags,
        };

    } catch (error) {
        console.error('[Gemini] Service error:', error);

        if (AI_CONFIG.useMockFallback) {
            console.log('[Gemini] Falling back to mock service');
            return mockGenerateMedia(selectedAngle, mediaType);
        }

        throw error;
    }
}

/**
 * Regenerate content with feedback
 */
export async function regenerateWithFeedback(
    selectedAngle: string,
    mediaType: MediaType,
    feedback: string
): Promise<MediaContent> {
    const apiKey = getGoogleAIKey();

    if (!apiKey) {
        return mockRegenerate(selectedAngle, mediaType, feedback);
    }

    // Incorporate feedback into the prompt
    const enhancedAngle = `${selectedAngle}\n\nUser feedback to incorporate: ${feedback}`;

    return generateMediaContent(enhancedAngle, mediaType);
}

// Video briefs are now generated by openaiService.ts using GPT-5

/**
 * Test Gemini API connection
 */
export async function testGeminiConnection(): Promise<{ success: boolean; message: string }> {
    const apiKey = getGoogleAIKey();

    if (!apiKey) {
        return { success: false, message: 'No API key configured' };
    }

    try {
        const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
        const response = await fetch(url);

        if (response.ok) {
            return { success: true, message: 'Connected successfully' };
        } else {
            const error = await response.json().catch(() => ({ error: { message: 'Unknown error' } }));
            return { success: false, message: error.error?.message || `Error: ${response.status}` };
        }
    } catch (error) {
        return { success: false, message: `Connection failed: ${error instanceof Error ? error.message : 'Unknown error'}` };
    }
}
