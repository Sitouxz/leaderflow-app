/**
 * Gemini service for generating visual content.
 * Uses Gemini 3 Pro for image generation (infographics, carousels, images).
 * Video briefs are generated by OpenAI GPT-5.
 */

import { GoogleGenAI } from "@google/genai";
import { AI_CONFIG, getGoogleAIKey, getGeminiConfig } from './aiConfig';
import { MediaType, MediaContent } from '@/types/pipeline';
import { generateMediaContent as mockGenerateMedia, regenerateWithFeedback as mockRegenerate } from './mockMediaDesign';
import { generateVideoBrief, generateSocialContent, generateImageGenPrompt } from './openaiService';



/**
 * Delay helper for retry logic
 */
function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Delay with countdown logging
 */
async function delayWithCountdown(ms: number, label: string): Promise<void> {
    const totalSeconds = Math.ceil(ms / 1000);
    console.log(`[${label}] Rate limited. Waiting ${totalSeconds} seconds...`);

    for (let remaining = totalSeconds; remaining > 0; remaining--) {
        if (remaining % 10 === 0 || remaining <= 5) {
            console.log(`[${label}] Retry in ${remaining}s...`);
        }
        await delay(1000);
    }
}

/**
 * Call Gemini API for image generation with retry logic using SDK
 */
async function callGeminiImageAPI(prompt: string, apiKey: string, retries = 3): Promise<string | null> {
    const ai = new GoogleGenAI({ apiKey });
    const geminiConfig = getGeminiConfig();

    // Configuration tailored to specific model
    const config: any = {
        responseModalities: ["IMAGE", "TEXT"],
    };

    // Add tools only for Pro model
    if (geminiConfig.model === 'gemini-3-pro-image-preview') {
        config.tools = [{ googleSearch: {} }];
    }

    // Always use 16:9 aspect ratio as "full" sizing
    config.imageConfig = {
        aspectRatio: "16:9"
    };

    // Add resolution if configured
    if (geminiConfig.imageSize) {
        config.imageConfig.imageSize = geminiConfig.imageSize;
    }

    for (let attempt = 0; attempt <= retries; attempt++) {
        try {
            console.log(`[Gemini] Generating image with ${geminiConfig.model} (Attempt ${attempt + 1}/${retries + 1})...`);

            // Using generateContentStream as per example
            const responseStream = await ai.models.generateContentStream({
                model: geminiConfig.model,
                contents: {
                    parts: [{ text: prompt }]
                },
                config: config
            });

            // Iterate chunks to find image data
            for await (const chunk of responseStream) {
                const parts = chunk.candidates?.[0]?.content?.parts || [];
                for (const part of parts) {
                    if (part.inlineData) {
                        return `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                    }
                }
            }

            console.warn('[Gemini] Stream completed but no image data found.');
            return null; // Don't retry immediately if successful request but no image, unless it's a known transient issue

        } catch (error: any) {
            console.error('[Gemini] API error:', error);

            const isRateLimit = error?.status === 429 || error?.code === 429 || error?.message?.includes('429') || error?.message?.includes('Too Many Requests');

            if (isRateLimit && attempt < retries) {
                // Fallback exponential backoff
                const waitTime = 5000 * Math.pow(2, attempt);
                await delayWithCountdown(waitTime, `Gemini Image (Attempt ${attempt + 1}/${retries})`);
                continue;
            }

            if (!isRateLimit) {
                return null;
            }
        }
    }

    return null;
}

/**
 * Generate media content using Gemini
 */
export async function generateMediaContent(
    selectedAngle: string,
    mediaType: MediaType
): Promise<MediaContent> {
    const apiKey = getGoogleAIKey();

    // Fall back to mock if no API key
    if (!apiKey) {
        console.log('[Gemini] No API key configured, using mock service');
        return mockGenerateMedia(selectedAngle, mediaType);
    }

    try {
        // Generate image prompt with OpenAI (High Quality) and text content in parallel
        // If OpenAI fails, it falls back to a default prompt internal to that service
        const [imagePrompt, socialContent] = await Promise.all([
            generateImageGenPrompt(selectedAngle, mediaType),
            generateSocialContent(selectedAngle, mediaType),
        ]);

        console.log('[Gemini] Generated specialized prompt:', imagePrompt);

        const imageUrl = await callGeminiImageAPI(imagePrompt, apiKey);

        // Use OpenAI-generated text content
        const { caption, description, hashtags } = socialContent;

        // If we got an image, use it; otherwise fall back to mock
        if (imageUrl) {
            const content: MediaContent = {
                type: mediaType,
                imageUrl,
                caption,
                description,
                hashtags,
            };

            // For carousel, generate additional images sequentially
            if (mediaType === 'carousel') {
                const additionalImages: string[] = [];

                // Try to get 3 distinct high-quality prompts from OpenAI
                // We typically need 2 more slides (total 3)
                // actually we want to replace the first image if possible? 
                // The flow is: we establish 'imagePrompt' (slide 1) earlier.
                // Let's keep slide 1 as the 'Hook' (generated above) and ask for 2 more.
                // OR we can ask for all 3 and use them. 
                // Let's try to get 3 specific prompts for the WHOLE carousel to be cohesive.

                // However, we already generated the first image using 'imagePrompt'.
                // Optimally, we should have detected 'carousel' earlier and generated 3 prompts then.
                // But refactoring `generateMediaContent` structure might be risky.

                // Plan:
                // 1. Fetch 3 prompts.
                // 2. We already have Slide 1 from the generic logic. We can keep it or discard it?
                //    Discarding is wasteful.
                //    Let's use the 'generateCarouselPrompts' which returns 3 prompts.
                //    And if we are in carousel mode, we should have called that INSTEAD of 'generateImageGenPrompt'.

                // Refactoring approach:
                // We will implement a specific branch for current logic:

                const carouselPrompts = await import('./openaiService').then(m => m.generateCarouselPrompts(selectedAngle));

                if (carouselPrompts.length === 3) {
                    // We have 3 perfect prompts.
                    // The first image was already generated with a generic prompt. 
                    // Let's generate Slide 2 and Slide 3 using the new specific prompts.
                    // Actually, the new prompts are (Hook, Insight, Solution).
                    // Slide 2 = Insight. Slide 3 = Solution.

                    console.log('[Gemini] Generating slide 2 (Insight)...');
                    const img2 = await callGeminiImageAPI(carouselPrompts[1], apiKey);
                    if (img2) additionalImages.push(img2);

                    console.log('[Gemini] Generating slide 3 (Solution)...');
                    const img3 = await callGeminiImageAPI(carouselPrompts[2], apiKey);
                    if (img3) additionalImages.push(img3);

                } else {
                    // Fallback to old variation logic
                    console.log('[Gemini] Generating slide 2 (Variation)...');
                    const img2 = await callGeminiImageAPI(imagePrompt + ' -- Variation: Focus on key details/statistics. Maintain style.', apiKey);
                    if (img2) additionalImages.push(img2);

                    console.log('[Gemini] Generating slide 3 (Variation)...');
                    const img3 = await callGeminiImageAPI(imagePrompt + ' -- Variation: Focus on practical application/next steps. Maintain style.', apiKey);
                    if (img3) additionalImages.push(img3);
                }

                content.previewUrls = [imageUrl, ...additionalImages];
            }

            // For video, generate brief using GPT-5
            if (mediaType === 'video') {
                content.videoBrief = await generateVideoBrief(selectedAngle);
            }

            return content;
        }

        // Fall back to mock if image generation failed
        console.log('[Gemini] Image generation failed, using mock with AI-generated text');
        const mockContent = await mockGenerateMedia(selectedAngle, mediaType);
        return {
            ...mockContent,
            caption,
            description,
            hashtags,
        };

    } catch (error) {
        console.error('[Gemini] Service error:', error);

        if (AI_CONFIG.useMockFallback) {
            console.log('[Gemini] Falling back to mock service');
            return mockGenerateMedia(selectedAngle, mediaType);
        }

        throw error;
    }
}

/**
 * Regenerate content with feedback
 */
export async function regenerateWithFeedback(
    selectedAngle: string,
    mediaType: MediaType,
    feedback: string
): Promise<MediaContent> {
    const apiKey = getGoogleAIKey();

    if (!apiKey) {
        return mockRegenerate(selectedAngle, mediaType, feedback);
    }

    // Incorporate feedback into the prompt
    const enhancedAngle = `${selectedAngle}\n\nUser feedback to incorporate: ${feedback}`;

    return generateMediaContent(enhancedAngle, mediaType);
}

/**
 * Test Gemini API connection
 */
export async function testGeminiConnection(): Promise<{ success: boolean; message: string }> {
    const apiKey = getGoogleAIKey();

    if (!apiKey) {
        return { success: false, message: 'No API key configured' };
    }

    try {
        // Use SDK to test connection via a simple generation
        const ai = new GoogleGenAI({ apiKey });
        const geminiConfig = getGeminiConfig();

        const config: any = {
            responseModalities: ["IMAGE", "TEXT"],
        };

        if (geminiConfig.model === 'gemini-3-pro-image-preview') {
            config.tools = [{ googleSearch: {} }];
        }

        config.imageConfig = {
            aspectRatio: "16:9"
        };

        if (geminiConfig.imageSize) {
            config.imageConfig.imageSize = geminiConfig.imageSize;
        }

        await ai.models.generateContent({
            model: geminiConfig.model,
            contents: { parts: [{ text: "Hello" }] },
            config: config
        });

        return { success: true, message: 'Connected successfully using ' + geminiConfig.model };

    } catch (error: any) {
        return { success: false, message: `Connection failed: ${error?.message || 'Unknown error'}` };
    }
}
